---
title: "SEAGRASS COVERAGE DASHBOARD"
output: 
  flexdashboard::flex_dashboard:
     logo: www/tarponlogo.png
     social: menu
     source_code: "https://github.com/tbep-tech/seagrass-dash"
     includes:
       in_header: cssloaders_in_header.html
runtime: shiny
css: styles.css
---

```{r setup, include=F}
knitr::opts_chunk$set(echo = F, message = F, warning = F)

library(flexdashboard)
library(tidyverse)
library(mapedit)
library(leaflet.extras)
library(sf)
library(mapview)
library(reactable)
library(shinydashboard)
library(shinyWidgets)
library(units)
library(plotly)
library(extrafont)
library(shinycssloaders)
library(networkD3)
library(tbeptools)

source('R/funcs.R')

# # style file
# styles <- readLines('https://raw.githubusercontent.com/tbep-tech/css-styling/master/styles.css')
# writeLines(styles, 'styles.css')

loadfonts(device = 'pdf', quiet = T)
if(Sys.info()[1] == 'Windows')
  loadfonts(device = 'win', quiet = T)

fml <- "Lato Light"

flcat <- list(
  code = c('7210', '9116', '9113', '9121'),
  name = c('sand', 'cont.', 'patchy', 'algae')
)

data(chgdat)
data(bardat)

data(sgdat1988)
data(sgdat1990)
data(sgdat1992)
data(sgdat1994)
data(sgdat1996)
data(sgdat1999)
data(sgdat2001)
data(sgdat2004)
data(sgdat2006)
data(sgdat2008)
data(sgdat2010)
data(sgdat2012)
data(sgdat2014)
data(sgdat2016)
data(sgdat2018)

prj <- 4326

allsg <- list(
    `1988` = sgdat1988,
    `1990` = sgdat1990,
    `1992` = sgdat1992,
    `1994` = sgdat1994,
    `1996` = sgdat1996,
    `1999` = sgdat1999,
    `2001` = sgdat2001,
    `2004` = sgdat2004,
    `2006` = sgdat2006,
    `2008` = sgdat2008,
    `2010` = sgdat2010,
    `2012` = sgdat2012,
    `2014` = sgdat2014,
    `2016` = sgdat2016,
    `2018` = sgdat2018
  ) %>%
  enframe('yr', 'data') %>%
  mutate(
    data = purrr::map(data, function(x){

      x <- x %>%
        mutate(
          FLUCCS_CODE = factor(FLUCCS_CODE, levels = flcat$code, labels = flcat$name)
        ) %>%
        select(OBJECTID, Category = FLUCCS_CODE)


      st_crs(x) <- prj

      return(x)

    })
  )

# cols <- c('tan', 'darkgreen', 'green', 'brown')
cols <- c('#D2B48C', '#006400', '#00FF00', '#A52A2A')
names(cols) <- c('sand', 'cont.', 'patchy', 'algae')
```

```{r reactives}
# filter all seagrass data by fluccs code
fltallsg <- reactive({

  # input
  flsel1 <- input$flsel1

  out <- allsg %>%
    mutate(
      data = purrr::map(data, function(x){

        x %>%
          filter(Category %in% flsel1) %>%
          mutate(Category = fct_drop(Category))

      })
    )

  return(out)

})

# year to plot
sgdat <- reactive({

  # input
  yrsel1 <- input$yrsel1
  fltallsg <- fltallsg()

  out <- fltallsg %>%
    filter(yr %in% yrsel1) %>%
    pull(data) %>%
    .[[1]]

  validate(
    need(nrow(out) > 0, 'No selection')
  )

  return(out)

})

# overview map, shows only simplified polygons
allmap1 <- reactive({

  # input
  yrsel1 <- input$yrsel1
  flsel1 <- input$flsel1
  
  flnm <- paste0('sgdat', yrsel1, 'simp')
  load(file = paste0('data/', flnm, '.RData'))
  
  tomap <- get(flnm) %>%
          filter(Category %in% flsel1) %>%
          mutate(Category = fct_drop(Category))

  # fix colors based on selection
  colreg <- cols[levels(tomap$Category)]

  out <- mapview(tomap, homebutton = F, zcol = 'Category', layer.name = 'Category', col.regions = colreg, color = 'grey', lwd = 0) %>%
    .@map

  return(out)

})

# reactive edits module for map selection
edits <- reactive({

  # input
  allmap1 <- allmap1()

  # this modifies available options in map selection toolber
  tomap <- allmap1 %>%
    addDrawToolbar(
      polylineOptions = FALSE,
      circleOptions = FALSE,
      circleMarkerOptions = FALSE,
      markerOptions = FALSE,
      editOptions = editToolbarOptions()#,
      # singleFeature = TRUE
    )

  out <- callModule(editMod, 'editor', tomap)

  return(out)

})

# selection from map as sf object, same crs as biodat
crpsel <- reactive({

  # input
  fltallsg <- fltallsg()
  edits <- edits()()

  # requires edits to continue
  validate(
    need(!is.null(edits$finished), 'Make a selection from the map using the draw features')
  )

  # get selection, calculate area
  tocrp <- edits$finished

  # check area of selection and validate
  chkarea <- st_area(tocrp) %>%
    set_units('acres') %>%
    as.numeric %>% 
    round(2)

  validate(
    need(chkarea > 1, paste0('Selected size is ', chkarea, ' acres and must be greater than 1 acre, please select a larger area'))
  )

  # crop and summarize by year
  out <- fltallsg %>%
    mutate(
      data = purrr::map(data, function(x){

        x <- st_intersection(tocrp, x) %>%
          mutate(
            area = st_area(.)
          ) 

        return(x)

      })
    )

  return(out)

})

# cropped sg data from map selection
mapsel <- reactive({

  # input
  crpsel <- crpsel()

  # crop and summarize by year
  out <- crpsel %>% 
    mutate(
      data = purrr::map(data, function(x) st_set_geometry(x, NULL))
    ) %>% 
    unnest('data') %>%
    group_by(yr, Category) %>%
    summarise(Acres = sum(area)) %>%
    ungroup %>%
    mutate(Acres = set_units(Acres, 'acres'))

  req(nrow(out) > 0)

  return(out)

})

# change estimates from map selection 
chgmapsel <- reactive({
  
  # input
  crpsel <- crpsel()
  flsel1 <- input$flsel1
  edits <- edits()()

  # requires edits to continue
  validate(
    need(!is.null(edits$finished), 'Make a selection from the map using the draw features')
  )
  
  # regex for filter
  fltval <- paste0('^', flsel1) %>% 
    gsub('\\.', '\\\\.', .) %>% 
    paste(., collapse = '|')

  # get selection, calculate area
  tocrp <- edits$finished

  # check area of selection and validate
  chkarea <- st_area(tocrp) %>%
    set_units('acres') %>%
    as.numeric %>% 
    round(2)

  validate(
    need(chkarea < 20000, paste0('Selected size is ', chkarea, ' acres and must be less than 20,000 acres, please select a smaller area'))
  )
  
  validate(
    need(chkarea > 1, paste0('Selected size is ', chkarea, ' acres and must be greater than 1 acre, please select a larger area'))
  )

  out <- chgfun(crpsel) %>% 
    filter(grepl(fltval, source)) %>% 
    filter(grepl(fltval, target))  
  
  return(out)
  
})

# table selection for download and reactable
seltab <- reactive({

  # input
  mapsel <- mapsel()

  out <- mapsel %>%
    mutate(Acres = as.numeric(Acres)) %>%
    spread(Category, Acres, fill = 0) %>%
    mutate(Total = rowSums(select(., -yr)))

  return(out)

})

# formatted selection table as reactable
frmseltab <- reactive({

  # input
  seltab <- seltab()

  out <- bartabfun(seltab)
  
  return(out)

})

# selection barplot
selplo <- reactive({

  # input
  mapsel <- mapsel()

  toplo <- mapsel %>%
    mutate(
      Acres = as.numeric(Acres)
    )

  p <- barplofun(toplo, cols, fml)

  return(p)

})

# fluccs change plot selection
chgselplo <- reactive({
  
  # inputs
  chgmapsel <- chgmapsel()
  nodpd1 <- input$nodpd1
  
  out <- sanplofun(chgmapsel, nodpd1)
  
  return(out)
  
})

# fluccs change table selection
chgseltab <- reactive({
  
  # input
  chgmapsel <- chgmapsel()
  
  out <- chgmapsel %>% 
    mutate(
      source_yr = as.numeric(gsub('^.*\\,\\s([0-9]+)$', '\\1', source)),
      target_yr = as.numeric(gsub('^.*\\,\\s([0-9]+)$', '\\1', target)), 
      source = gsub('\\,\\s[0-9]+$', '', source), 
      target = gsub('\\,\\s[0-9]+$', '', target)
    ) %>% 
    spread(target, value, fill = 0) %>% 
    rename(
      Category = source, 
      `Start year` = source_yr, 
      `End year` = target_yr
    )
  
  return(out)
  
})

# fluccs change table by selection, reactable
chgselrcttab <- reactive({
  
  # input
  chgseltab <- chgseltab()
  
  out <- reactable(chgseltab,
    columns = list(
      `Start year` = colDef(format = colFormat(separators = F)),
      `End year` = colDef(format = colFormat(separators = F))
    ),
    defaultColDef = colDef(
      footerStyle = list(fontWeight = "bold"),
      format = colFormat(digits = 0, separators = TRUE),
      resizable = TRUE
    ),
   filterable = T,
   defaultPageSize = 12
  )
  
  return(out)
  
})

# overview segment map, shows only simplified polygons
allmap2 <- reactive({

  # input
  yrsel2 <- input$yrsel2
  flsel2 <- input$flsel2
  snkseg <- input$snkseg
  
  flnm <- paste0('sgdat', yrsel2, 'simp')
  load(file = paste0('data/', flnm, '.RData'))
  
  tomap <- get(flnm) %>%
          filter(Category %in% flsel2) %>%
          mutate(Category = fct_drop(Category))

  segmap <- tbseg %>% 
    filter(bay_segment %in% !!snkseg)
  
  # fix colors based on selection
  colreg <- cols[levels(tomap$Category)]

  mapout <- mapview(tomap, homebutton = F, zcol = 'Category', layer.name = 'Category', col.regions = colreg, lwd = 0) +
     mapview(segmap, homebutton = F, legend = F, col.regions = 'grey95', lwd = 3, zcol = 'long_name', alpha.regions = 0.5) 
  
  out <- mapout@map

  return(out)

})

# segment selection data
segsel <- reactive({
  
  # input
  snkseg <- input$snkseg
  flsel2 <- input$flsel2
  
  # regex for filter
  fltval <- paste0('^', flsel2) %>% 
    gsub('\\.', '\\\\.', .) %>% 
    paste(., collapse = '|')
  
  out <- bardat %>%
    filter(bay_segment %in% !!snkseg) %>% 
    filter(grepl(fltval, Category))
  
  return(out)
  
})

# table selection for download and reactable
segtab <- reactive({

  # input
  segsel <- segsel()

  out <- segsel %>%
    mutate(Acres = as.numeric(Acres)) %>%
    spread(Category, Acres, fill = 0) %>%
    mutate(Total = rowSums(select(., -yr)))

  return(out)

})

# formatted segment table as reactable
frmsegtab <- reactive({

  # input
  segtab <- segtab()

  out <- bartabfun(segtab)

  return(out)

})

# segment barplot 
segplo <- reactive({

  # input
  segsel <- segsel()

  toplo <- segsel %>%
    mutate(
      Acres = as.numeric(Acres)
    )

  p <- barplofun(toplo, cols, fml)

  return(p)

})

# fluccs change data by segment
chgseg <- reactive({

  snkseg <- input$snkseg
  flsel2 <- input$flsel2
  
  req(!is.null(flsel2))
  
  # regex for filter
  fltval <- paste0('^', flsel2) %>% 
    gsub('\\.', '\\\\.', .) %>% 
    paste(., collapse = '|')
  
  # filter by segment and fluccs
  out <- chgdat %>%
    filter(bay_segment %in% !!snkseg) %>% 
    filter(grepl(fltval, source)) %>% 
    filter(grepl(fltval, target))  
  
  return(out)
  
})

# fluccs change table by segment
chgsegtab <- reactive({
  
  # input
  chgseg <- chgseg()
  
  out <- chgseg %>% 
    select(-bay_segment) %>% 
    mutate(
      source_yr = as.numeric(gsub('^.*\\,\\s([0-9]+)$', '\\1', source)),
      target_yr = as.numeric(gsub('^.*\\,\\s([0-9]+)$', '\\1', target)), 
      source = gsub('\\,\\s[0-9]+$', '', source), 
      target = gsub('\\,\\s[0-9]+$', '', target)
    ) %>% 
    spread(target, value, fill = 0) %>% 
    rename(
      Category = source, 
      `Start year` = source_yr, 
      `End year` = target_yr
    )
  
  return(out)
  
})

# fluccs change table by segment, reactable
chgsegrcttab <- reactive({
  
  # input
  chgsegtab <- chgsegtab()
  
  out <- reactable(chgsegtab,
    columns = list(
      `Start year` = colDef(format = colFormat(separators = F)),
      `End year` = colDef(format = colFormat(separators = F))
    ),
    defaultColDef = colDef(
      footerStyle = list(fontWeight = "bold"),
      format = colFormat(digits = 0, separators = TRUE),
      resizable = TRUE
    ),
   filterable = T,
   defaultPageSize = 12
  )
  
  return(out)
  
})

# sankey flow chart by segment
chgsegplo <- reactive({
  
  # input
  chgseg <- chgseg()
  nodpd2 <- input$nodpd2
  
  out <- sanplofun(chgseg, nodpd2)  
  
  return(out)
  
})
```

```{r downloadhandlers}
# selected data
output$seldl1 <- downloadHandler(
  filename = function(){'mapbar.csv'},
  content = function(file){
    
    # inputs
    seltab <- seltab()
    
    write.csv(seltab, file, quote = T, row.names = F)
    
  }
)

# selected data
output$seldl2 <- downloadHandler(
  filename = function(){'segmentbar.csv'},
  content = function(file){
    
    # inputs
    segtab <- segtab()
    
    write.csv(segtab, file, quote = T, row.names = F)
    
  }
)

# selected segment data
output$selsegdl1 <- downloadHandler(
  filename = function(){'mapchange.csv'},
  content = function(file){
    
    # inputs
    chgseltab <- chgseltab()
    
    write.csv(chgseltab, file, quote = T, row.names = F)
    
  }
)

# selected segment data
output$selsegdl2 <- downloadHandler(
  filename = function(){'segmentchange.csv'},
  content = function(file){
    
    # inputs
    chgsegtab <- chgsegtab()
    
    write.csv(chgsegtab, file, quote = T, row.names = F)
    
  }
)
```

CHANGE BY SELECTION
===========================================================

Column {data-width=250}
-----------------------------------------------------------------------

```{r}
# selection editor
editModUI('editor') %>% withSpinner()
```

Column {.tabset .tabset-fade}
-----------------------------------------------------------------------

```{r}
column(12,
  br(),
  column(4, selectInput('yrsel1', 'Select year on map:', choices = allsg$yr, selected = '2018')),
  column(4, selectInput('flsel1', 'Select categories:', choices = c(flcat$name, 'other'), selected = c(flcat$name, 'other'), multiple = T)),
)
```

### BARPLOT

```{r}
output$selplo <- renderPlotly(selplo())
output$frmseltab <- renderReactable(frmseltab())
fillCol(flex = c(NA, 1),
  column(12, 
    column(3, selectInput('segres1', 'Choose summary output:', choices = c('plot', 'table')))
    ),
  renderUI({
    
    # input
    segres1 <- input$segres1
    
    if(segres1 == 'plot')
      return(plotlyOutput('selplo'))
    
    if(segres1 == 'table'){
      out <- fillCol(flex = c(NA, 1),
        renderUI({
          req(!is.null(edits()()$finished))
          downloadBttn('seldl1', 'Download data', style = 'simple', block = T, color = 'success')
        }),
        reactableOutput('frmseltab')
      )
      return(out)
    }
    
  })
)
```

### CHANGE PLOT

```{r}
output$chgselplo <- renderSankeyNetwork(chgselplo())
output$chgselrcttab <- renderReactable(chgselrcttab())
fillCol(flex = c(NA, 1),
  column(12, 
    column(3, selectInput('segres2', 'Choose summary output:', choices = c('plot', 'table'))),
    column(3, numericInput('nodpd1', 'Change spacing (plot only):', min = 0, max = 300, step = 10, value = 100))
    ),
  renderUI({
    
    # input
    segres2 <- input$segres2
    
    if(segres2 == 'plot')
      return(sankeyNetworkOutput('chgselplo'))
    
    if(segres2 == 'table'){
      out <- fillCol(flex = c(NA, 1),
        downloadBttn('selsegdl1', 'Download data', style = 'simple', block = T, color = 'success'),
        reactableOutput('chgselrcttab')
      )
      return(out)
    }
    
  })
)
```

CHANGE BY BAY SEGMENT
===========================================================

Column {data-width=250}
-----------------------------------------------------------------------

```{r}
output$allmap2 <- renderLeaflet(allmap2())
leafletOutput('allmap2', height = '100%')
```

Column {.tabset .tabset-fade}
-----------------------------------------------------------------------

```{r}
column(12,
  br(),
  column(4, selectInput('yrsel2', 'Select year on map:', choices = allsg$yr, selected = '2018')),
  column(4, selectInput('snkseg', 'Choose bay segment:', choices = list('Old Tampa Bay' = 'OTB', 'Hillsborough Bay' = 'HB', 'Middle Tampa Bay' = 'MTB', 'Lower Tampa Bay' = 'LTB'))),
  column(4, selectInput('flsel2', 'Select categories:', choices = c(flcat$name, 'other'), selected = c(flcat$name, 'other'), multiple = T)),
)

```

### BARPLOT

```{r}
output$segplo <- renderPlotly(segplo())
output$frmsegtab <- renderReactable(frmsegtab())
fillCol(flex = c(NA, 1),
  column(12, 
    column(3, selectInput('segres3', 'Choose summary output:', choices = c('plot', 'table')))
    ),
  renderUI({
    
    # input
    segres3 <- input$segres3
    
    if(segres3 == 'plot')
      return(plotlyOutput('segplo'))
    
    if(segres3 == 'table'){
      out <- fillCol(flex = c(NA, 1),
        renderUI({
          req(!is.null(edits()()$finished))
          downloadBttn('seldl2', 'Download data', style = 'simple', block = T, color = 'success')
        }),
        reactableOutput('frmsegtab')
      )
      return(out)
    }
    
  })
)
```

### CHANGE PLOT

```{r}
output$chgsegplo <- renderSankeyNetwork(chgsegplo())
output$chgsegrcttab <- renderReactable(chgsegrcttab())
fillCol(flex = c(NA, 1),
  column(12, 
    column(3, selectInput('segres4', 'Choose summary output:', choices = c('plot', 'table'))),
    column(3, numericInput('nodpd2', 'Change spacing (plot only):', min = 0, max = 300, step = 10, value = 100))
    ),
  renderUI({
    
    # input
    segres4 <- input$segres4
    
    if(segres4 == 'plot')
      return(sankeyNetworkOutput('chgsegplo'))
    
    if(segres4 == 'table'){
      out <- fillCol(flex = c(NA, 1),
        downloadBttn('selsegdl2', 'Download data', style = 'simple', block = T, color = 'success'),
        reactableOutput('chgsegrcttab')
      )
      return(out)
    }
    
  })
)
```

### YEAR VS YEAR